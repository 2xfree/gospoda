# Broj (80 points)

The first and the easiest of the binary exploitation challenges.

We are provided with the following code.

```c
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char const *argv[])
{
    char input[10];
    fgets(input, 10, stdin);
    float a;
    a = atof(input);
    if (a <= 0 || a > 0)
    {
        return 0;
    }
    FILE *f;
    f = fopen("./flag.txt", "r");
    char flag[100];
    fread(flag, 100, 1, f);
    fclose(f);
    puts(flag);
    return 0;
}
```

At first it seems that `a <= 0 || a > 0` will always be true, right?

Well not really, because `atof` accepts a peculiar little input `NaN`.
I did not know this at first and when I finally found it I got caught off guard,
`NaN` is something I would expect of javascript, not C.

But my personal feelings about `NaN` aside, let's try it on the server:

```text
 ~ $ nc chal.hackultet.hr 13017
NaN
CTF2024[491634754943]
```

One binary exploitation challenge down, five more to go. 

------
Useful resources:

[atof (cppreference.com)](https://en.cppreference.com/w/c/string/byte/atof)
